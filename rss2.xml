<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>宋竹温 | 不羁跬步</title>
    <link>https://www.wendellsun.com/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description></description>
    <pubDate>Tue, 31 Mar 2020 04:07:11 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>尝无止尽路由</title>
      <link>https://www.wendellsun.com/2020/03/31/%E5%B0%9D%E6%97%A0%E6%AD%A2%E5%B0%BD%E8%B7%AF%E7%94%B1/</link>
      <guid>https://www.wendellsun.com/2020/03/31/%E5%B0%9D%E6%97%A0%E6%AD%A2%E5%B0%BD%E8%B7%AF%E7%94%B1/</guid>
      <pubDate>Tue, 31 Mar 2020 03:46:00 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;sc
          
        
      
      </description>
      
      <content:encoded><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="Hungry-Router-尝无止尽路由"><a href="#Hungry-Router-尝无止尽路由" class="headerlink" title="Hungry Router - 尝无止尽路由"></a>Hungry Router - 尝无止尽路由</h3><p>步入硅器时代的中期，互联网逐渐进行的城市化，已经让原先的博客原住民变成了一座座孤岛。早年间繁荣的航海发现已经变得萧条，浏览世界的工具，也从孤身一人富含冒险勇气的Safari/Explorer，变成了社区群体汇集丰富多元的Chrome。孤岛的生活自由精致，不求浮名，但求同好。</p><h3 id="硅矿工匠"><a href="#硅矿工匠" class="headerlink" title="硅矿工匠"></a>硅矿工匠</h3><p><a href="http://freemind.pluskid.org/rss.xml" target="_blank" rel="noopener">Free Mind</a> - Free Mind<br><a href="http://www.shuang0420.com/atom.xml" target="_blank" rel="noopener">徐阿衡</a> - Shuang<br><a href="http://liqi.io/feed/" target="_blank" rel="noopener">利器</a> - 创造者和他们的工具<br><a href="http://spaces.ac.cn/index.php/feed/" target="_blank" rel="noopener">科学空间|Scientific Spaces</a> - 渴望成为一个小飞侠<br><a href="http://www.geekplux.com/atom.xml" target="_blank" rel="noopener">GeekPlux</a> - Data Visualization &amp; Full-stack programmer @ finance firm, Blogger, Cat lover, Lifelong learner.<br><a href="https://rsshub.app/blogs/wangyin" target="_blank" rel="noopener">王垠的博客 - 当然我在扯淡</a> - 王垠的博客 - 当然我在扯淡<br><a href="https://blog.genkun.me/index.xml" target="_blank" rel="noopener">GENKUN</a> - Recent content on GENKUN<br><a href="https://joeycz.github.io/weekly/rss.xml" target="_blank" rel="noopener">每周记录SEE</a> - 每周记录SEE<br><a href="http://www.huanglu.club/feed.xml" target="_blank" rel="noopener">Lu Huang’s Blog</a> - Lu Huang’s Blog<br><a href="http://iconmoon.com/blog2/feed.php" target="_blank" rel="noopener">图月志</a> - JJ Ying 的界面设计博客，博主同时也是设计播客 Anyway.FM 的主播<br><a href="http://www.anotherhome.net/feed" target="_blank" rel="noopener">Hi, DIYgod</a> - Hi, DIYgod<br><a href="http://yihui.name/cn/feed/" target="_blank" rel="noopener">中文日志 on Yihui Xie | 谢益辉</a> - Recent content in 中文日志 on Yihui Xie | 谢益辉<br><a href="https://digitalimmigrant.org/feed" target="_blank" rel="noopener">数字移民</a> - 数字移民是一种生活方式<br><a href="http://jcf94.com/atom.xml" target="_blank" rel="noopener">Chenfan Blog</a> - Do cool things that matter.<br><a href="https://www.hrwhisper.me/feed/" target="_blank" rel="noopener">细语呢喃</a> - 技术改变生活<br><a href="https://charlesliuyx.github.io/atom.xml" target="_blank" rel="noopener">Go Further</a> - Stay Hungry, Stay Foolish<br><a href="https://www.onespiece.com/blog/feed.xml" target="_blank" rel="noopener">ONES Piece 翻译计划 - 聚焦科技、创投和商业</a> - ONES Piece是一个由ONES Ventures发起的非营利翻译计划，聚焦科技、创投和商业。<br><a href="http://www.infoier.com/feed/" target="_blank" rel="noopener">infoier | 设计乘数</a> - infoier | 设计乘数<br><a href="http://www.zlovezl.cn/feeds/latest/" target="_blank" rel="noopener">piglei</a> - piglei<br><a href="https://anyway.fm/news/rss.xml" target="_blank" rel="noopener">安妮薇时报 Anyway.News</a> - 由 Anyway.FM 发行，为你提供与设计行业相关的新闻资讯、网摘推荐以及专栏文章等内容。<br><a href="http://beforweb.com/rss.xml" target="_blank" rel="noopener">Be For Web</a> - Be For Web<br><a href="https://lastone.art/feed/" target="_blank" rel="noopener">一稿计划</a> - Last one  </p><h3 id="游吟诗稿"><a href="#游吟诗稿" class="headerlink" title="游吟诗稿"></a>游吟诗稿</h3><p><a href="http://blog.itgonglun.com/feed/" target="_blank" rel="noopener">一天世界</a> - 一天世界<br><a href="https://chengbao.bitcron.com/feed" target="_blank" rel="noopener">城堡阅读周刊</a> - 由阅读爱好者业余制作，基于 Markdown 排版的网络独立杂志。<br><a href="http://mindhacks.cn/feed/" target="_blank" rel="noopener">刘未鹏 | Mind Hacks</a> - 思维改变生活<br><a href="https://goldengrape.github.io/rss.xml" target="_blank" rel="noopener">GoldenGrape’s Blog</a> - This is a blog site for GoldenGrape.<br><a href="https://jesor.me/feed.xml" target="_blank" rel="noopener">大破进击</a> - 大破进击<br><a href="https://jhuo.ca/index.xml" target="_blank" rel="noopener">HuoJu’s BLOG</a> - Recent content on HuoJu’s BLOG<br><a href="http://www.chinanonfiction.com/feed/" target="_blank" rel="noopener">累牍</a> - 累牍<br><a href="http://gravitysworm.tumblr.com/rss" target="_blank" rel="noopener">万有引力之虫</a> - 在刺猬与狐狸之外，在傻子和英雄之间。 A blog about social movement and others.  </p><h3 id="播波电台"><a href="#播波电台" class="headerlink" title="播波电台"></a>播波电台</h3><p><a href="http://nj.lizhi.fm/rss/14275.xml" target="_blank" rel="noopener">大内密谈</a> - 大内密谈<br><a href="https://rss.simplecast.com/podcasts/1897/rss" target="_blank" rel="noopener">UX Coffee 设计咖</a> - 设计无处不在。在这个节目里，我们试图通过和设计这个世界的人们交谈，去探寻创造的过程、感受设计的力量。<br><a href="https://theue.me/feed/podcast" target="_blank" rel="noopener">无业游民 The Unemployable</a> - 生活再丧，也不要和世界失去联系<br><a href="http://www.spreaker.com/show/2571819/episodes/feed" target="_blank" rel="noopener">文化土豆 Culture Potato</a> - 文化土豆 Culture Potato<br><a href="http://lushu88.com/rss" target="_blank" rel="noopener">路书</a> - 路书<br><a href="https://jinjinledao.org/?feed=rss2" target="_blank" rel="noopener">津津乐道</a> - 用耳朵体验世界<br><a href="https://feeds.fireside.fm/czgx/rss" target="_blank" rel="noopener">迟早更新</a> - by ONES Ventures<br><a href="http://www.ximalaya.com/album/5574153.xml" target="_blank" rel="noopener">日谈公园</a> - 日谈公园<br><a href="http://busangpodcast.com/episodes/feed.xml" target="_blank" rel="noopener">不丧</a> - Busang Podcast<br><a href="https://www.bukelilun.com/rss" target="_blank" rel="noopener">不可理论</a> - 带你用理论理解生活<br><a href="https://pretro.xyz/feed" target="_blank" rel="noopener">提前怀旧</a> - 一切未来终将成为过去。欢迎收听《提前怀旧》，一档由任宁和 Rio 主持的科技评论节目。<br><a href="http://storyfm.cn/feed/episodes" target="_blank" rel="noopener">故事 FM</a> - 用你的声音，讲述你的故事。<br><a href="http://hardimage.pro/rss" target="_blank" rel="noopener">硬影像</a> - 硬影像<br><a href="https://museelogue.fireside.fm/rss" target="_blank" rel="noopener">博物志</a> - 博物志<br><a href="https://feeds.fireside.fm/yitianshijie/rss" target="_blank" rel="noopener">一天世界</a> - 一天世界，昆乱不挡。不鳥萬如一主理。IPN 出品。<br><a href="https://ipn.li/crazycapital/feed" target="_blank" rel="noopener">疯投圈</a> - 疯投圈<br><a href="http://fashionmonster.fm/rss" target="_blank" rel="noopener">时尚怪物</a> - Fashion Monster 《时尚怪物》是一档探讨文化艺术与奇奇怪怪生活的播客节目，Tianxi、汉洋主持，IPN 出品。<br><a href="http://www.ximalaya.com/album/3558668.xml" target="_blank" rel="noopener">黑水公园</a> - 黑水公园<br><a href="https://feeds.fireside.fm/surplusvalue/rss" target="_blank" rel="noopener">剩余价值SurplusValue</a> - 剩余价值SurplusValue<br><a href="http://www.typeisbeautiful.com/feed/typechat/" target="_blank" rel="noopener">字谈字畅</a> - 用听觉方式扯视觉艺术<br><a href="https://pythonhunter.org/episodes/feed.xml" target="_blank" rel="noopener">捕蛇者说</a> - 编程、程序员、Python<br><a href="http://anyway.fm/rss.xml" target="_blank" rel="noopener">Anyway.FM 设计杂谈</a> - 由 UI 设计师 JJ Ying 和 Leon Gao 主播的 podcast，主题包括但不限于视觉设计，入选 2015 年 Apple 最佳播客榜单。Anyway.FM 是两个闷骚男抒发对设计热情的地方、Anyway.FM 是两个老男人吐槽世界的地方、Anyway.FM 也是一对好基友想把自己的见解分享给更多人的地方。  </p>]]></content:encoded>
      
      <comments>https://www.wendellsun.com/2020/03/31/%E5%B0%9D%E6%97%A0%E6%AD%A2%E5%B0%BD%E8%B7%AF%E7%94%B1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>时间和因果性</title>
      <link>https://www.wendellsun.com/2020/02/01/%E6%97%B6%E9%97%B4%E5%92%8C%E5%9B%A0%E6%9E%9C%E6%80%A7/</link>
      <guid>https://www.wendellsun.com/2020/02/01/%E6%97%B6%E9%97%B4%E5%92%8C%E5%9B%A0%E6%9E%9C%E6%80%A7/</guid>
      <pubDate>Sat, 01 Feb 2020 08:25:54 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;sc
          
        
      
      </description>
      
      <content:encoded><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="时间和因果性"><a href="#时间和因果性" class="headerlink" title="时间和因果性"></a>时间和因果性</h2><p>春节肺炎的群体隔离期间，看了片单里罗列很久的电影，恰好又在书架上看到初中那会特别喜欢的一本书《Hyperspace 超越时空》。这本书算是一本「超空间理论」的科普读物，全书基本奉行「霍金畅销书」理论，全篇没有用一个公式，只是通过举例和类比的文学方式来描述近代物理的一个很争议的「超空间理论」。</p><p>除去四大基本力的统一，最有吸引力的就是对「时间」的解读。作为一个抽象又具象的名词，宗教、哲学、文学、艺术领域都又有不同的流派对这个词有所解释。在时间的科幻应用上谈及最多的就是「时间旅行」，这里又可以衍生出很多的假说来描述时间旅行的种种问题。</p><p>此前我也作为一个定性分析爱好者，喜欢琢磨「时间旅行」的可解释性。那个时候我最认同的是时间旅行的经历只是可观测性但不可修改的，就像在地球看到几亿光年外的星体，可以通过改变和它的空间距离来看到这个星体的过去和未来。现在的自己认知来看这种自己觉得可解释性最强的假说无疑不够精妙，这种假说下，空间和时间维度还是被揉捏在一起，没有那种正交互相独立的美感。</p><p>刷电影片单的过程带了些新的思考，一直以来最容易理解时间维度的方式就是视频，天然有一个可供调整的进度条来切换时间的位置。从这点来看，文学作品也是差不多，书籍的页码同样是自带的「时间进度条」，在电子阅读软件上同样也是这么使用的。不过电影和文学的叙事表达有很多手法，很难有纯线性叙事的作品了，这一点来看，切换的时间轴反而会更容易陷入事件时间的先后错乱中。但这种非线性叙事其实很接近时间旅行，提前或延后知晓在一件事情还没发生或者发生后的场景故事。</p><p>就像空间维度上的人可以从A走到B，作为正交的时间轴应该也能修改，像视频剪辑软件那样，把白天的人下一秒就安排在黑夜。但这种粗暴的方式无疑会破坏因果性，无数时间旅行的假说就是为了满足因果性而产生的，大致可以归纳为宿命论和非宿命论。但这些都是认为一件事情发生后会像蝴蝶效应那样导致一件事情发生，只是那件事情的结果，可能会，也可能不会，如同时间旅行前那样。这就是为了体现时间的因果性。但有没有可能时间是没有因果性的，我把叉了苹果的叉子往嘴里伸，然后吃到了牛肉。</p><p>我自己其实一直也觉得时间和因果性应该深深地绑定在一起，或者说时间只是因果的产物，但物理上真的是这样吗？鉴于是为了探索脑洞的趣味性，我只是在知乎上看了看现有的讨论。</p><p>最直接的问题就是<a href="https://www.zhihu.com/question/23105401/answer/23648308" target="_blank" rel="noopener">「因果」是建立在「时间」这个概念上的吗？</a> 虽然和我想的时间是不是因果的产物有所差异，但其实探讨的本质是一样的。毫无疑问，这类的问题解读最先要做的是对因果和时间进行定义，不同的定义会延伸出不同的解读结论。但只是作为脑洞探索，分析各类定义的不同结论实在过于繁琐。按照康德的因果观和相对论的时空观解读来看，因果和时间都是光传递的内容，也就是说在得知时间同时也能知道因果的作用。似乎以一种回避的方式讨论了时间和因果的关系，但的确也没办法进行任何的实验来描绘二者的关系。定性的分析成了这类问题的最大的遗憾。</p><p>像电影视听表达那样无视前一秒和后一秒的因果性，这是一种免于时空旅行各类悖论的取巧方式。但这种简单粗暴的覆盖像是一种偷懒，实在很难让人相信这是世界运转的规律之一。</p>]]></content:encoded>
      
      <comments>https://www.wendellsun.com/2020/02/01/%E6%97%B6%E9%97%B4%E5%92%8C%E5%9B%A0%E6%9E%9C%E6%80%A7/#disqus_thread</comments>
    </item>
    
    <item>
      <title>9900k+2080ti 7月推荐配置</title>
      <link>https://www.wendellsun.com/2019/07/19/9900k-2080ti-7%E6%9C%88%E7%BD%AE%E6%8E%A8%E8%8D%90/</link>
      <guid>https://www.wendellsun.com/2019/07/19/9900k-2080ti-7%E6%9C%88%E7%BD%AE%E6%8E%A8%E8%8D%90/</guid>
      <pubDate>Fri, 19 Jul 2019 05:28:27 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;sc
          
        
      
      </description>
      
      <content:encoded><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="中央处理单元-CPU"><a href="#中央处理单元-CPU" class="headerlink" title="中央处理单元-CPU"></a>中央处理单元-CPU</h3><p>cpu 的话消费顶级选择当然不止intel 9900k,另一个可以选择的是7月新出的AMD 3900x， 价格两者差不多（4k左右）。从数据上看 3900x的核心和线程数都比较高，（9900k-8核16线程 | 3900x-12核24线程）但一方面是我对amd 的处理器不太了解，主板选择上和内存支持上可能没有太大把握，同时由于本月新品的原因，配套主板的价格特别高。另一方面实际游戏测试表现来看默频下，9900k略胜3900x一筹（平均高出6%），超频下9900k（5ghz）还是略胜3900x(auto)一筹（平均高出5%,但9900k超频空间大很多)。所以游戏娱乐来看现在买9900k还是一个比较好的选择，至于专业视频制作和数据处理3900x因为核心线程的领先表现可能会好一点。</p><p>Refer：<a href="https://www.techspot.com/review/1877-core-i9-9900k-vs-ryzen-9-3900x/" target="_blank" rel="noopener">9900k和3900x游戏性能对比</a></p><h3 id="主板-Motherboard"><a href="#主板-Motherboard" class="headerlink" title="主板-Motherboard"></a>主板-Motherboard</h3><p>主板的话 如果不超频的话微星的暗黑版本就够用了，但是m2接口和供电还是寒酸了一点，如果后续要加m2硬盘会少一两个，用微星战神ace的话如果超频的话供电能更稳定一点，i/o和硬盘接口更丰富一点，毕竟现在主板一键超频还是比较容易的，超频不是很复杂。华硕的rog m11h 和 微星 战神 ace差不多，但有rog的灯效和品牌加成，不过如果选择rog 我比较建议再加一点钱到 m11a，rog的顶级供电，可以挑战一波液氮超频。 美观的话rog m11f比较好看<br>如果选微星暗黑注意下只有结尾带ac的是自带无线网卡和蓝牙的。</p><p>Refer：<a href="https://www.bhphotovideo.com/c/compare/MSI_MPG_Z390_GAMING_PRO_CARBON_AC_vs_ASUS_MAXIMUS_IX_HERO_vs_ASUS_ROG_MAXIMUS_XI_EXTREME_vs_MSI_MEG_Z390_ACE/BHitems/1437832-REG_1438191-REG_1444349-REG_1437827-REG" target="_blank" rel="noopener">msi carbon | msi ace | rog m11h |rog m11e主板对比</a></p><h3 id="图形处理单元-GPU"><a href="#图形处理单元-GPU" class="headerlink" title="图形处理单元-GPU"></a>图形处理单元-GPU</h3><p>gpu的话是十分价钱一分货，一千块一两帧的差距吧，1w左右的看造型选就行了，如果还是比较看中频率的话微星魔龙在这个价位有一点点优势，建议主板和显卡选择同品牌的，这样在软件监控管理上稍微方便一点点。如果主板选了rog，显卡可以选rog的猛禽。</p><h3 id="内存-Memory"><a href="#内存-Memory" class="headerlink" title="内存-Memory"></a>内存-Memory</h3><p>内存的话有两个方向一个是追求空间的16g双通道，另一个是追求频率的8g双通道，性能上高频率的8g双通道在游戏上表现会好一点（10%以内），一张主板能插四条内存，性能要求高又对空间要求不太高（不跑大数据处理和高分辨率的影视动画制作）4个8gb的绝对够用了，如果空间要求比较大还是16g的内存吧(rog 主板是只有两个内存槽 除了m11e)</p><h3 id="硬盘-Disk"><a href="#硬盘-Disk" class="headerlink" title="硬盘-Disk"></a>硬盘-Disk</h3><p>硬盘的话不太知道你原来硬盘的型号，主控颗粒还是新硬盘好一点，4k读写能快很多，建议还是用新m2硬盘装个系统500g或者250g的都可以，但500g的性能会好一点。硬盘的话价格高的在跑分上还是比较明显的，但使用感受区别不大。而且硬盘不太保值，换起来又方便，随用随换可能比较好一点。</p><h3 id="电源-Power"><a href="#电源-Power" class="headerlink" title="电源-Power"></a>电源-Power</h3><p>电源 如果打算5年后下一台电脑接着用的话可以用1000w的电源，质保时限都是ok的，850w其实也够下一台用，但余量不一定够，不过电源用得太久也不一定100%稳定。至于rog的雷神用的是同款海韵电源的带灯贴皮，不过一般机箱电源位都是带仓包起来的，所以带了灯可能也看不见。</p><h3 id="散热-CPU-Cooler"><a href="#散热-CPU-Cooler" class="headerlink" title="散热-CPU Cooler"></a>散热-CPU Cooler</h3><p>散热我查了一下，水冷有几个5年损坏全赔的，可以具体问一下客服，就是如果漏夜造成你机箱损伤他们会折旧赔其他部件比如cpu/gpu的钱。9900k的发热量还是比较大的，如果用风冷真的是装一个硕大硕大的散热塔，还得有额外的承重架来支撑一下（不过显卡估计也会需要支撑架），水冷能让机箱整洁一点。不过水冷不太好带到日本，路上颠簸说不定就影响整体密封性了。不管选水冷还是风冷都要注意机箱尺寸，水冷一般机箱描述会写有支持360冷排，风冷的话最好问一下客服猫头鹰或大霜塔能不能装进去，而且还要注意会不会挡住主板的一些接口位置</p><h3 id="机箱-Computer-Case"><a href="#机箱-Computer-Case" class="headerlink" title="机箱-Computer Case"></a>机箱-Computer Case</h3><p>机箱 注意支持主板大小是不是支持atx主板，前面板对type-c有没有要求（rog m11h主板不支持机箱前面板的type-c），散热装不装得下，别的就没什么了，主要还是看你对造型的喜好。我个人觉得rog 太阳神这样就还行。但你最好多挑挑，毕竟低头不见抬头见</p><p>参考推荐表—<a href="https://docs.google.com/spreadsheets/d/1khBTbdek9qIB4ak9juU6ajG2TTHB3lIDeFttdxKnS_o/edit?usp=sharing" target="_blank" rel="noopener">9900k+2080ti 7月简单推荐配置</a><br><img src="https://raw.githubusercontent.com/PsYear/PictureCloud/master/9900k%2B2080ti%E9%85%8D%E7%BD%AE%E6%8E%A8%E8%8D%90.jpg" alt="9900k+2080ti 7月简单推荐配置"></p>]]></content:encoded>
      
      <comments>https://www.wendellsun.com/2019/07/19/9900k-2080ti-7%E6%9C%88%E7%BD%AE%E6%8E%A8%E8%8D%90/#disqus_thread</comments>
    </item>
    
    <item>
      <title>利器</title>
      <link>https://www.wendellsun.com/2019/07/04/%E5%88%A9%E5%99%A8/</link>
      <guid>https://www.wendellsun.com/2019/07/04/%E5%88%A9%E5%99%A8/</guid>
      <pubDate>Thu, 04 Jul 2019 07:53:40 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;sc
          
        
      
      </description>
      
      <content:encoded><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>下载:  <a href="https://motrix.app/" target="_blank" rel="noopener">motrix</a> - 可以作为迅雷部分无法下载资源的备用，部分迅雷服务器可以缓存的资源，速度还是迅雷更快</p><p>code展示: <a href="https://carbon.now.sh/" target="_blank" rel="noopener">Carbon</a></p><p>mac 录屏幕：<a href="https://giphy.com/apps/giphycapture" target="_blank" rel="noopener">GIPHY CAPTURE</a></p><p>Markdown: <a href="https://www.typora.io" target="_blank" rel="noopener">Typora</a></p><p>Mysql gui: <a href="https://www.sequelpro.com/" target="_blank" rel="noopener">sequel pro</a> - mac上非常容易操作的轻量mysql gui，当然大部分情况下python的mysql包就完全够用了</p><p>Gist gui：<a href="https://hackjutsu.com/Lepton/" target="_blank" rel="noopener">Lepton</a> - 比较好用的gist桌面应用，可惜没有搜索功能</p>]]></content:encoded>
      
      <comments>https://www.wendellsun.com/2019/07/04/%E5%88%A9%E5%99%A8/#disqus_thread</comments>
    </item>
    
    <item>
      <title>本站使用的hexo额外插件</title>
      <link>https://www.wendellsun.com/2019/07/02/%E6%9C%AC%E7%AB%99%E4%BD%BF%E7%94%A8%E7%9A%84hexo%E9%A2%9D%E5%A4%96%E6%8F%92%E4%BB%B6/</link>
      <guid>https://www.wendellsun.com/2019/07/02/%E6%9C%AC%E7%AB%99%E4%BD%BF%E7%94%A8%E7%9A%84hexo%E9%A2%9D%E5%A4%96%E6%8F%92%E4%BB%B6/</guid>
      <pubDate>Tue, 02 Jul 2019 05:51:31 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;sc
          
        
      
      </description>
      
      <content:encoded><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><ul><li><a href="http://duyana.top/post/59d52da5/" target="_blank" rel="noopener">gitalk</a></li><li><a href="https://getpocket.com/redirect?url=https%3A%2F%2Ftianma.space%2Fpost%2F3998746934%2Findex.html" target="_blank" rel="noopener">hexo-tag-aplayer</a></li><li><a href="https://www.jianshu.com/p/6eb068a68b17" target="_blank" rel="noopener">百度统计</a></li><li><a href="https://lfwen.site/2016/11/13/next-busuanzi-vistor-count/" target="_blank" rel="noopener">不蒜子</a></li><li><a href="https://figma.com" target="_blank" rel="noopener">Figma</a>各类icon制作</li></ul><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference:"></a>Reference:</h3><p><a href="http://theme-next.iissnan.com/theme-settings.html" target="_blank" rel="noopener">Hexo NexT主题配置文档</a><br><a href="https://postgres.fun/20181027203300.html" target="_blank" rel="noopener">Hexo: 给博客添加百度统计</a><br><a href="https://asdfv1929.github.io/2018/05/26/next-add-music/" target="_blank" rel="noopener">Hexo NexT主题中添加网页音乐播放器功能</a><br><a href="https://huabuyu.net/Hexo-NexT-%E6%89%93%E9%80%A0APlayer-HTML5-%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8.html" target="_blank" rel="noopener">Hexo NexT 打造APlayer HTML5 音乐播放器</a><br><a href="https://iochen.com/2018/01/06/use-gitalk-in-hexo/" target="_blank" rel="noopener">Hexo中Gitalk配置使用教程-可能是目前最详细的教程</a><br><a href="http://blog.sciencenet.cn/blog-3247241-1139774.html" target="_blank" rel="noopener">hexo博客解决不蒜子统计无法显示问题</a></p>]]></content:encoded>
      
      <comments>https://www.wendellsun.com/2019/07/02/%E6%9C%AC%E7%AB%99%E4%BD%BF%E7%94%A8%E7%9A%84hexo%E9%A2%9D%E5%A4%96%E6%8F%92%E4%BB%B6/#disqus_thread</comments>
    </item>
    
    <item>
      <title>「The score」意外小众的流行摇滚组合</title>
      <link>https://www.wendellsun.com/2019/07/02/%E3%80%8CThe-score%E3%80%8D%E6%84%8F%E5%A4%96%E5%B0%8F%E4%BC%97%E7%9A%84%E6%B5%81%E8%A1%8C%E6%91%87%E6%BB%9A%E7%BB%84%E5%90%88/</link>
      <guid>https://www.wendellsun.com/2019/07/02/%E3%80%8CThe-score%E3%80%8D%E6%84%8F%E5%A4%96%E5%B0%8F%E4%BC%97%E7%9A%84%E6%B5%81%E8%A1%8C%E6%91%87%E6%BB%9A%E7%BB%84%E5%90%88/</guid>
      <pubDate>Tue, 02 Jul 2019 05:49:17 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;sc
          
        
      
      </description>
      
      <content:encoded><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script>    <div id="aplayer-yPMivQtg" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="471411253" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#FF4081"></div><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference:"></a>Reference:</h3><p><a href="https://github.com/metowolf/MetingJS#option" target="_blank" rel="noopener">MetingJS</a></p>]]></content:encoded>
      
      <comments>https://www.wendellsun.com/2019/07/02/%E3%80%8CThe-score%E3%80%8D%E6%84%8F%E5%A4%96%E5%B0%8F%E4%BC%97%E7%9A%84%E6%B5%81%E8%A1%8C%E6%91%87%E6%BB%9A%E7%BB%84%E5%90%88/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Bert FineTune 实践</title>
      <link>https://www.wendellsun.com/2018/11/23/Bert-FineTune-%E5%AE%9E%E8%B7%B5/</link>
      <guid>https://www.wendellsun.com/2018/11/23/Bert-FineTune-%E5%AE%9E%E8%B7%B5/</guid>
      <pubDate>Thu, 22 Nov 2018 16:00:00 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;sc
          
        
      
      </description>
      
      <content:encoded><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>从11月初开始，<a href="https://github.com/google-research" target="_blank" rel="noopener">google-research</a>就陆续开源了<a href="https://github.com/google-research/bert" target="_blank" rel="noopener">bert</a>的各个版本。google此次开源的bert是通过tensorflow高级API—— <code>tf.estimator</code>进行封装(wrapper)的。因此对于不同数据集的适配，只需要修改代码中的processor部分，就能进行代码的训练、交叉验证和测试。</p><h2 id="在自己的数据集上运行bert"><a href="#在自己的数据集上运行bert" class="headerlink" title="在自己的数据集上运行bert"></a>在自己的数据集上运行bert</h2><p>bert的代码同论文里描述的一致，主要分为两个部分。一个是训练语言模型（language model）的预训练（pretrain）部分。另一个是训练具体任务(task)的fine-tune部分。在开源的代码中，预训练的入口是在<code>run_pretraining.py</code>而fine-tune的入口针对不同的任务分别在<code>run_classifier.py</code>和<code>run_squad.py</code>。其中<code>run_classifier.py</code>适用的任务为分类任务。如CoLA、MRPC、MultiNLI这些数据集。而<code>run_squad.py</code>适用的是阅读理解(MRC)任务，如squad2.0和squad1.1。预训练是bert很重要的一个部分，与此同时，预训练需要巨大的运算资源。按照论文里描述的参数，其Base的设定在消费级的显卡Titan x 或Titan 1080ti(12GB RAM)上，甚至需要近几个月的时间进行预训练，同时还会面临显存不足的问题。不过所幸的是谷歌满足了<a href="https://github.com/google-research/bert/issues/2" target="_blank" rel="noopener">issues#2</a>里各国开发者的请求，针对大部分语言都公布了bert的<a href="https://github.com/google-research/bert/blob/master/multilingual.md" target="_blank" rel="noopener">预训练模型</a>。因此在我们可以比较方便得在自己的数据集上进行fine-tune。</p><h3 id="下载预训练模型"><a href="#下载预训练模型" class="headerlink" title="下载预训练模型"></a>下载预训练模型</h3><p>对于中文而言，google公布了一个参数较小的bert预训练模型。具体参数数值如下所示：</p><blockquote><p>Chinese Simplified and Traditional, 12-layer, 768-hidden, 12-heads, 110M parameters  </p></blockquote><p>模型的<a href="https://storage.googleapis.com/bert_models/2018_11_03/chinese_L-12_H-768_A-12.zip" target="_blank" rel="noopener">下载链接</a>可以在github上google的开源代码里找到。对下载的压缩文件进行解压，可以看到文件里有五个文件，其中bert_model.ckpt开头的文件是负责模型变量载入的，而vocab.txt是训练时中文文本采用的字典，最后bert_config.json是bert在训练时，可选调整的一些参数。</p><h3 id="修改processor"><a href="#修改processor" class="headerlink" title="修改processor"></a>修改processor</h3><p>任何模型的训练、预测都是需要有一个明确的输入，而bert代码中processor就是负责对模型的输入进行处理。我们以分类任务的为例，介绍如何修改processor来运行自己数据集上的fine-tune。在<code>run_classsifier.py</code>文件中我们可以看到，google对于一些公开数据集已经写了一些processor，如<code>XnliProcessor</code>,<code>MnliProcessor</code>,<code>MrpcProcessor</code>和<code>ColaProcessor</code>。这给我们提供了一个很好的示例，指导我们如何针对自己的数据集来写processor。<br>对于一个需要执行训练、交叉验证和测试完整过程的模型而言，自定义的processor里需要继承DataProcessor，并重载获取label的<code>get_labels</code>和获取单个输入的<code>get_train_examples</code>,<code>get_dev_examples</code>和<code>get_test_examples</code>函数。其分别会在<code>main</code>函数的<code>FLAGS.do_train</code>、<code>FLAGS.do_eval</code>和<code>FLAGS.do_predict</code>阶段被调用。<br>这三个函数的内容是相差无几的，区别只在于需要指定各自读入文件的地址。以<code>get_train_examples</code>为例，函数需要返回一个由<code>InputExample</code>类组成的<code>list</code>。<code>InputExample</code>类是一个很简单的类，只有初始化函数，需要传入的参数中guid是用来区分每个example的，可以按照<code>train-%d&#39;%(i)</code>的方式进行定义。text_a是一串字符串，text_b则是另一串字符串。在进行后续输入处理后(bert代码中已包含，不需要自己完成) text_a和text_b将组合成<code>[CLS] text_a [SEP] text_b [SEP]</code>的形式传入模型。最后一个参数label也是字符串的形式，label的内容需要保证出现在<code>get_labels</code>函数返回的<code>list</code>里。<br>举一个例子，假设我们想要处理一个能够判断句子相似度的模型，现在在<code>data_dir</code>的路径下有一个名为<code>train.csv</code>的输入文件，如果我们现在输入文件的格式如下csv形式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1,你好,您好</span><br><span class="line">0,你好,你家住哪</span><br></pre></td></tr></table></figure><p>那么我们可以写一个如下的<code>get_train_examples</code>的函数。当然对于csv的处理，可以使用诸如<code>csv.reader</code>的形式进行读入。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_train_examples</span><span class="params">(self, data_dir)</span>：</span></span><br><span class="line">    file_path = os.path.join(data_dir, 'train.csv')</span><br><span class="line">    <span class="keyword">with</span> open(file_path, <span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        reader = f.readlines()</span><br><span class="line">    examples = []</span><br><span class="line">    <span class="keyword">for</span> index, line <span class="keyword">in</span> enumerate(reader):</span><br><span class="line">        guid = <span class="string">'train-%d'</span>%index</span><br><span class="line">        split_line = line.strip().split(<span class="string">','</span>)</span><br><span class="line">        text_a = tokenization.convert_to_unicode(split_line[<span class="number">1</span>])</span><br><span class="line">        text_b = tokenization.convert_to_unicode(split_line[<span class="number">2</span>])</span><br><span class="line">        label = split_line[<span class="number">0</span>]</span><br><span class="line">        examples.append(InputExample(guid=guid, text_a=text_a,</span><br><span class="line">                                        text_b=text_b, label=label))</span><br><span class="line">    <span class="keyword">return</span> examples</span><br></pre></td></tr></table></figure><p>同时对应判断句子相似度这个二分类任务，<code>get_labels</code>函数可以写成如下的形式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_labels</span><span class="params">(self)</span>:</span></span><br><span class="line">    reutrn [<span class="string">'0'</span>,<span class="string">'1'</span>]</span><br></pre></td></tr></table></figure><p>在对<code>get_dev_examples</code>和<code>get_test_examples</code>函数做类似<code>get_train_examples</code>的操作后，便完成了对processor的修改。其中<code>get_test_examples</code>可以传入一个随意的label数值，因为在模型的预测（prediction）中label将不会参与计算。  </p><h3 id="修改processor字典"><a href="#修改processor字典" class="headerlink" title="修改processor字典"></a>修改processor字典</h3><p>修改完成processor后，需要在在原本<code>main</code>函数的processor字典里，加入修改后的processor类，即可在运行参数里指定调用该processor。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">processors = &#123;</span><br><span class="line">     <span class="string">"cola"</span>: ColaProcessor,</span><br><span class="line">     <span class="string">"mnli"</span>: MnliProcessor,</span><br><span class="line">     <span class="string">"mrpc"</span>: MrpcProcessor,</span><br><span class="line">     <span class="string">"xnli"</span>: XnliProcessor, </span><br><span class="line">     <span class="string">"selfsim"</span>: SelfProcessor <span class="comment">#添加自己的processor</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="运行fine-tune"><a href="#运行fine-tune" class="headerlink" title="运行fine-tune"></a>运行fine-tune</h3><p>之后就可以直接运行<code>run_classsifier.py</code>进行模型的训练。在运行时需要制定一些参数，一个较为完整的运行参数如下所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> BERT_BASE_DIR=/path/to/bert/chinese_L-12_H-768_A-12 <span class="comment">#全局变量 下载的预训练bert地址</span></span><br><span class="line"><span class="built_in">export</span> MY_DATASET=/path/to/xnli <span class="comment">#全局变量 数据集所在地址</span></span><br><span class="line"></span><br><span class="line">python run_classifier.py \</span><br><span class="line">  --task_name=selfsim \ <span class="comment">#自己添加processor在processors字典里的key名</span></span><br><span class="line">  --do_train=<span class="literal">true</span> \</span><br><span class="line">  --do_eval=<span class="literal">true</span> \</span><br><span class="line">  --dopredict=<span class="literal">true</span> \</span><br><span class="line">  --data_dir=<span class="variable">$MY_DATASET</span> \</span><br><span class="line">  --vocab_file=<span class="variable">$BERT_BASE_DIR</span>/vocab.txt \</span><br><span class="line">  --bert_config_file=<span class="variable">$BERT_BASE_DIR</span>/bert_config.json \</span><br><span class="line">  --init_checkpoint=<span class="variable">$BERT_BASE_DIR</span>/bert_model.ckpt \</span><br><span class="line">  --max_seq_length=128 \ <span class="comment">#模型参数</span></span><br><span class="line">  --train_batch_size=32 \</span><br><span class="line">  --learning_rate=5e-5 \</span><br><span class="line">  --num_train_epochs=2.0 \</span><br><span class="line">  --output_dir=/tmp/selfsim_output/ <span class="comment">#模型输出路径</span></span><br></pre></td></tr></table></figure><h2 id="bert源代码里还有什么"><a href="#bert源代码里还有什么" class="headerlink" title="bert源代码里还有什么"></a>bert源代码里还有什么</h2><p>在开始训练我们自己fine-tune的bert后，我们可以再来看看bert代码里除了processor之外的一些部分。<br>我们可以发现，process在得到字符串形式的输入后，在<code>file_based_convert_examples_to_features</code>里先是对字符串长度，加入[CLS]和[SEP]等一些处理后，将其写入成TFrecord的形式。这是为了能在estimator里有一个更为高效和简易的读入。<br>我们还可以发现，在<code>create_model</code>的函数里，除了从<code>modeling.py</code>获取模型主干输出之外，还有进行fine-tune时候的loss计算。因此，如果对于fine-tune的结构有自定义的要求，可以在这部分对代码进行修改。如进行NER任务的时候，可以按照bert论文里的方式，不只读第一位的logits，而是将每一位logits进行读取。<br>bert这次开源的代码，由于是考虑在google自己的TPU上高效地运行，因此采用的estimator是<code>tf.contrib.tpu.TPUEstimator</code>,虽然tpu的estimator同样可以在gpu和cpu上运行，但若想在gpu上更高效得做一些提升，可以考虑将其换成<code>tf.estimator.Estimator</code>,于此同时model_fn里一些<code>tf.contrib.tpu.TPUEstimatorSpec</code>也需要修改成<code>tf.estimator.EstimatorSpec</code>的形式，以及相关调用参数也需要做一些调整。在转换成较普通的estimator后便可以使用常用的方式对estimator进行处理，如生成用于部署的<code>.pb</code>文件等。</p><h2 id="issues里一些有趣的内容"><a href="#issues里一些有趣的内容" class="headerlink" title="issues里一些有趣的内容"></a>issues里一些有趣的内容</h2><p>从google对bert进行开源开始，issues里的讨论便异常活跃，bert论文第一作者javob devlin也积极地在issues里进行回应，在交流讨论中，产生了一些很有趣的内容。<br>在<a href="https://github.com/google-research/bert/issues/95" target="_blank" rel="noopener">#95</a>中大家讨论了bert模型在今年ai-challenger比赛上的应用。我们也同样尝试了bert在ai-challenger的mrc赛道的表现。如果简单得地将mrc的文本连接成一个长字符串的形式，可以在dev集上得到79.1%的准确率。如果参考openAI的GPT<a href="https://s3-us-west-2.amazonaws.com/openai-assets/research-covers/language-unsupervised/language_understanding_paper.pdf" target="_blank" rel="noopener">论文</a>里multi-choice的形式对bert的输入输出代码进行修改则可以将准确率提高到79.3%。采用的参数都是bert默认的参数，而单一模型成绩在赛道的test a排名中已经能超过榜单上的第一名。因此，在相关中文的任务中，bert能有很大的想象空间。<br>在<a href="https://github.com/google-research/bert/issues/123" target="_blank" rel="noopener">#123</a>中，<a href="https://github.com/hanxiao" target="_blank" rel="noopener">@hanxiao</a>给出了一个采用ZeroMQ便捷部署bert的service，可以直接调用训练好的模型作为应用的接口。同时他将bert改为一个大的encode模型，将文本通过bert进行encode，来实现句子级的encode。此外，他对比了多GPU上的性能，发现bert在多GPU并行上的出色表现。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总得来说，google此次开源的bert和其预训练模型是非常有价值的，可探索和改进的内容也很多。相关数据集上已经出现了对bert进行修改后的复合模型，如squad2.0上哈工大(HIT)的<code>AoA + DA + BERT</code>以及西湖大学（DAMO）的<code>SLQA + BERT</code>。<br>在感谢google这份付出的同时，我们也可以借此站在巨人的肩膀上，尝试将其运用在自然语言处理领域的方方面面，让人工智能的梦想更近一步。</p><h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>本文相关工作在<a href="https://naturali.io/" target="_blank" rel="noopener">©奇点机智</a>工作期间完成，已授权<a href="https://naturali.io/" target="_blank" rel="noopener">©奇点机智</a>对文章的各类使用。</p>]]></content:encoded>
      
      <comments>https://www.wendellsun.com/2018/11/23/Bert-FineTune-%E5%AE%9E%E8%B7%B5/#disqus_thread</comments>
    </item>
    
    <item>
      <title>用Graphs的运行方式执行Eager模式的代码</title>
      <link>https://www.wendellsun.com/2018/10/12/%E7%94%A8Graphs%E7%9A%84%E8%BF%90%E8%A1%8C%E6%96%B9%E5%BC%8F%E6%89%A7%E8%A1%8CEager%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BB%A3%E7%A0%81/</link>
      <guid>https://www.wendellsun.com/2018/10/12/%E7%94%A8Graphs%E7%9A%84%E8%BF%90%E8%A1%8C%E6%96%B9%E5%BC%8F%E6%89%A7%E8%A1%8CEager%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BB%A3%E7%A0%81/</guid>
      <pubDate>Thu, 11 Oct 2018 16:00:00 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;sc
          
        
      
      </description>
      
      <content:encoded><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>一、在执行代码时使用 <code>tf.enable_eager_execution()</code> 开启eager模式</p><p>二、正向传播支持自定义class类型  </p><ol><li><a href="https://github.com/tensorflow/tensorflow/blob/master/tensorflow/contrib/eager/python/examples/rnn_ptb/rnn_ptb.py#L99" target="_blank" rel="noopener">定义</a>的model继承keras.model<br></li><li>在<a href="https://github.com/tensorflow/tensorflow/blob/master/tensorflow/contrib/eager/python/examples/rnn_ptb/rnn_ptb.py#L110" target="_blank" rel="noopener"><strong>init</strong>()</a>里定义所用到的layer类型<br></li><li>在<a href="https://github.com/tensorflow/tensorflow/blob/master/tensorflow/contrib/eager/python/examples/rnn_ptb/rnn_ptb.py#L133" target="_blank" rel="noopener">call()</a>里连接layer，返回<a href="https://github.com/tensorflow/tensorflow/blob/master/tensorflow/contrib/eager/python/examples/rnn_ptb/rnn_ptb.py#L146" target="_blank" rel="noopener">output</a><br></li></ol><p>二、反向传播的使用  </p><ol><li><p>先用tf的api定义<a href="https://github.com/tensorflow/tensorflow/blob/master/tensorflow/contrib/eager/python/examples/rnn_ptb/rnn_ptb.py#L158" target="_blank" rel="noopener">loss函数</a><br></p></li><li><p>用tfe的<a href="https://www.tensorflow.org/api_docs/python/tf/contrib/eager/implicit_gradients" target="_blank" rel="noopener">api</a>调用loss得到梯度grads  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tfe.gradients_function(loss,x)</span><br><span class="line">tfe.implicit_gradients(loss)</span><br></pre></td></tr></table></figure><p>或者也可以采用<a href="https://www.tensorflow.org/api_docs/python/tf/GradientTape" target="_blank" rel="noopener">GradientTape(y,x)</a>来进行计算可以根据函数y计算变量x的梯  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> tf.GradientTape() <span class="keyword">as</span> grad_tape:</span><br><span class="line">    grad_tape.gradient(y,x)</span><br></pre></td></tr></table></figure><p>在tf的诸多eager execution样例中里用第二种方法较多  </p></li><li><p>用tf定义的<a href="https://github.com/tensorflow/tensorflow/blob/master/tensorflow/contrib/eager/python/examples/rnn_ptb/rnn_ptb.py#L317" target="_blank" rel="noopener">optimizer</a>优化梯度更新参数  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">optimizer.apply_gradients(grad)</span><br></pre></td></tr></table></figure></li></ol><p>三、Eager的输入使用<code>tf.data.Dataset</code>但不支持<code>placeholder</code>和<code>string_input_producer</code>这类在graph模式中使用的输入</p><p>四、使用<code>tf.train.Checkpoint()</code><a href="https://www.tensorflow.org/api_docs/python/tf/train/Checkpoint" target="_blank" rel="noopener">保存</a>模型的checkpoint</p><p>五、可以使用<code>tf.contrib.eager.defun</code>对python的函数进行封装转换成图的形式进行运算。用eager的写法可以实现graph的运算速度。  </p><ol><li><p>使用了defun的forward propagation例子如下:  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">model.call = tf.contrib.eager.defun(model.call)</span><br><span class="line">model(x, training=<span class="literal">True</span>)  <span class="comment"># executes a graph, with dropout</span></span><br></pre></td></tr></table></figure></li><li><p>一个使用了defun的back propagation例子如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">optimizer = tf.train.GradientDescentOptimizer()</span><br><span class="line"><span class="keyword">with</span> tf.GradientTape() <span class="keyword">as</span> tape:</span><br><span class="line">    outputs = model(x)</span><br><span class="line">gradient = tape.gradient(outputs, model.trainable_variables)</span><br><span class="line">defun_gradients = tfe.defun(gradient)</span><br><span class="line">tfe.defun(optimizer.apply_gradients((grad, var) <span class="keyword">for</span> grad, </span><br><span class="line">                var <span class="keyword">in</span> zip(gradient,model.trainable_variables)))</span><br></pre></td></tr></table></figure><p>然而此后<a href="https://www.tensorflow.org/api_docs/python/tf/contrib/eager/defun" target="_blank" rel="noopener">defun</a>可能会被<a href="https://medium.com/tensorflow/autograph-converts-python-into-tensorflow-graphs-b2a871f87ec7" target="_blank" rel="noopener">AutoGraph</a>替代</p></li></ol><p>Refer:<a href="https://medium.com/tensorflow/code-with-eager-execution-run-with-graphs-optimizing-your-code-with-revnet-as-an-example-6162333f9b08?linkId=55410234" target="_blank" rel="noopener">Code with Eager Execution, Run with Graphs: Optimizing Your Code with RevNet as an Example</a></p>]]></content:encoded>
      
      <comments>https://www.wendellsun.com/2018/10/12/%E7%94%A8Graphs%E7%9A%84%E8%BF%90%E8%A1%8C%E6%96%B9%E5%BC%8F%E6%89%A7%E8%A1%8CEager%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BB%A3%E7%A0%81/#disqus_thread</comments>
    </item>
    
    <item>
      <title>checkpoint增加一些可阅读性的操作</title>
      <link>https://www.wendellsun.com/2018/09/21/checkpoint%E5%A2%9E%E5%8A%A0%E4%B8%80%E4%BA%9B%E5%8F%AF%E9%98%85%E8%AF%BB%E6%80%A7%E7%9A%84%E6%93%8D%E4%BD%9C/</link>
      <guid>https://www.wendellsun.com/2018/09/21/checkpoint%E5%A2%9E%E5%8A%A0%E4%B8%80%E4%BA%9B%E5%8F%AF%E9%98%85%E8%AF%BB%E6%80%A7%E7%9A%84%E6%93%8D%E4%BD%9C/</guid>
      <pubDate>Thu, 20 Sep 2018 16:00:00 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;sc
          
        
      
      </description>
      
      <content:encoded><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="checkpoint增加一些可阅读性的操作"><a href="#checkpoint增加一些可阅读性的操作" class="headerlink" title="checkpoint增加一些可阅读性的操作"></a>checkpoint增加一些可阅读性的操作</h3><p>checkpoint的基础使用在官方的<a href="https://www.tensorflow.org/guide/saved_model" target="_blank" rel="noopener">手册</a>里描述地比较清楚了。但在进行迁移学习时，需要对一些预训练的权重进行读取，因此如果能可阅读得打印一些变量，可以使得读取过程变得简捷便利。</p><h4 id="checkpoint里变量名和权重值"><a href="#checkpoint里变量名和权重值" class="headerlink" title="checkpoint里变量名和权重值"></a>checkpoint里变量名和权重值</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tensorflow.python <span class="keyword">import</span> pywrap_tensorflow</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line">model_dir = <span class="string">'dir'</span></span><br><span class="line">file_name = <span class="string">'ckptfile'</span></span><br><span class="line"></span><br><span class="line">checkpoint_path = os.path.join(model_dir,file_name)</span><br><span class="line">reader = pywrap_tensorflow.NewCheckpointReader(checkpoint_path)</span><br><span class="line">var_to_shape_map = reader.get_variable_to_shape_map()</span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> var_to_shape_map:</span><br><span class="line">    print(<span class="string">'tensor_name: '</span>,key) <span class="comment">#变量名</span></span><br><span class="line">    print(reader.get_tensor(key)) <span class="comment">#变量值</span></span><br></pre></td></tr></table></figure><p>在ckpt文件里的变量有两类，一类是进行前馈的权重，另一类是在后馈时的梯度。同时有一些变量并不是此前在构建模型时声明的，而是在实现各类模型api时自动产生的，通常这类变量会根据参数产生W和bias。对于包含多步线性计算的cell即各类RNN的cell而言，W会被整合成一个名为kernel的变量，其tensor大小将根据具体的计算方式生成，如lstm的kernel变量大小为(input_dim+lstm_dim,4*lstm_dim)。</p><h4 id="sess里变量读取预训练权重"><a href="#sess里变量读取预训练权重" class="headerlink" title="sess里变量读取预训练权重"></a>sess里变量读取预训练权重</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sess.run(tf.global_variables_initializer())</span><br><span class="line">sess.run(tf.local_variables_initializer())</span><br><span class="line">print_variable = [var.name <span class="keyword">for</span> var <span class="keyword">in</span> tf.global_variables()]</span><br><span class="line">print(print_variable)</span><br></pre></td></tr></table></figure><p>因为ckpt读取变量需要新变量和ckpt里的变量名字完全一致，所以可以通过上述代码查看变量名是否满足条件。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">variables_to_restore = [var <span class="keyword">for</span> var <span class="keyword">in</span> tf.global_variables()</span><br><span class="line">    <span class="keyword">if</span> var.name==<span class="string">'bias:0'</span> <span class="keyword">or</span> var.name==<span class="string">'kernel:0'</span>]</span><br><span class="line">saver = tf.train.Saver(variables_to_restore)</span><br><span class="line">model_dir = <span class="string">'dir'</span></span><br><span class="line">file_name = <span class="string">'ckptfile'</span></span><br><span class="line">checkpoint_path = os.path.join(model_dir,file_name)</span><br><span class="line">saver.restore(self.sess,checkpoint_path)</span><br></pre></td></tr></table></figure><p>通过在saver初始化时传入需要读取的参数，可以控制restore哪些变量。</p>]]></content:encoded>
      
      <comments>https://www.wendellsun.com/2018/09/21/checkpoint%E5%A2%9E%E5%8A%A0%E4%B8%80%E4%BA%9B%E5%8F%AF%E9%98%85%E8%AF%BB%E6%80%A7%E7%9A%84%E6%93%8D%E4%BD%9C/#disqus_thread</comments>
    </item>
    
    <item>
      <title>estimator的简单使用方式</title>
      <link>https://www.wendellsun.com/2018/09/13/estimator%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F/</link>
      <guid>https://www.wendellsun.com/2018/09/13/estimator%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F/</guid>
      <pubDate>Wed, 12 Sep 2018 16:00:00 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;sc
          
        
      
      </description>
      
      <content:encoded><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="estimator的简单使用方式"><a href="#estimator的简单使用方式" class="headerlink" title="estimator的简单使用方式"></a>estimator的简单使用方式</h3><p><a href="https://www.tensorflow.org/programmers_guide/estimators?hl=zh-cn" target="_blank" rel="noopener">estimator</a>的官方使用方式介绍了使用自定义的estimator的model，没有涉及到从keras的model来使用estimator。<br>主要的使用方式来自这篇<a href="https://github.com/kashif/tf-keras-tutorial/blob/master/7-estimators-multi-gpus.ipynb" target="_blank" rel="noopener">notebook</a>在使用的时候没有遇上太多障碍。<br>但有一些细节花了一点时间去调试。<br>比如estimator能按照dataset重复次数<code>dataset.repeat(n)</code>作为epoch，因此如果直接使用<code>dataset.repeat()</code>会在训练时陷入死循环。</p><h4 id="model-fn的处理"><a href="#model-fn的处理" class="headerlink" title="model_fn的处理"></a>model_fn的处理</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">model_fn</span><span class="params">(features, labels, mode)</span>:</span></span><br><span class="line">    keras_estimator_obj = tf.keras.estimator.model_to_estimator(</span><br><span class="line">        keras_model=base_model,</span><br><span class="line">        model_dir=&lt;model_dir&gt;,</span><br><span class="line">        config=&lt;run_config&gt;,</span><br><span class="line">    ) </span><br><span class="line"></span><br><span class="line">    <span class="comment"># pull model_fn that we need (hack)</span></span><br><span class="line">    <span class="keyword">return</span> keras_estimator_obj._model_fn</span><br></pre></td></tr></table></figure><p>通过传递参数是无法打印更多的训练结果，但是可以通过创建一个logging hook来让estimator运行。<br>In the body of model_fn function for your estimator:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">logging_hook = tf.train.LoggingTensorHook(&#123;<span class="string">"loss"</span> : loss, </span><br><span class="line">    <span class="string">"accuracy"</span> : accuracy&#125;, every_n_iter=<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Rest of the function</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> tf.estimator.EstimatorSpec(</span><br><span class="line">    ...params...</span><br><span class="line">    training_hooks = [logging_hook])</span><br></pre></td></tr></table></figure><p>除了<code>self.estimator.train()</code>以外,可以使用<code>tf.estimator.train_and_evaluate()</code>对<code>train</code>和<code>evaluate</code>进行更精细地操作。  </p><p>此外<code>add_metrics(estimator,my_auc)</code>只是把metrics加入到最终结果的输出里，而不是每一次step，对于每一次step需要在<code>EstimatorSpec(training_hook=[logging_hook])</code>里添加logging_hook</p><p>多gpu出现的<br>All hooks must be SessionRunHook instances问题在<a href="https://github.com/tensorflow/tensorflow/issues/21444" target="_blank" rel="noopener">#issues21444</a> 里解决，等待tf-1.11版本。</p>]]></content:encoded>
      
      <comments>https://www.wendellsun.com/2018/09/13/estimator%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
